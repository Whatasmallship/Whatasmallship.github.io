<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>干点啥好呢</title><meta name="author" content="Me"><meta name="copyright" content="Me"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="干点啥好呢">
<meta property="og:url" content="http://example.com/">
<meta property="og:site_name" content="干点啥好呢">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Whatasmallship/imgbed-for-self-blog/wallpaper/4a19190013a4b3f98d0370f6645db29.jpg">
<meta property="article:author" content="Me">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Whatasmallship/imgbed-for-self-blog/wallpaper/4a19190013a4b3f98d0370f6645db29.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '干点啥好呢',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-09-17 22:01:10'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Whatasmallship/imgbed-for-self-blog/wallpaper/4a19190013a4b3f98d0370f6645db29.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/></div></div><div class="page" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="干点啥好呢"><span class="site-name">干点啥好呢</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/06/11/%E5%91%A8%E6%8A%A5%E6%B1%87%E6%80%BB/" title="周报汇总（持续更新）"><i class="fas fa-thumbtack sticky"></i>周报汇总（持续更新）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-06-11T15:30:31.000Z" title="发表于 2024-06-11 23:30:31">2024-06-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Learning-Record/">Learning-Record</a></span></div><div class="content">202406
0608
Principles of Large-Scale Machine Learning [Lecture1、2]

Estimating the empirical risk with samples


Empirical Risk介绍


计算加速措施：并行化、小批量梯度下降、硬件加速、近似计算


近似计算Empirical Risk的原理


子采样
引入随机变量 Z，代表随机采样一个样本的损失值。多次独立地抽取 Z 的样本，这些样本的平均值将近似于经验风险 R~emp~。


大数定律
根据统计学原理，一组独立随机变量的平均值往往聚集在该随机变量的期望值周围。


中心极限定理
随着我们采样更多的 Z，样本平均值会越来越接近真实的期望值。


集中不等式
随机变量 Z 集中在某个取值附近的概率：马尔可夫不等式、切比雪夫不等式、霍夫丁不等式。





0610
PyTorch


Tensor Tutorial


初始化
属性：shape、dtype、device等
操作：转置、索引、切分等


Autograd Tutorial


神经网络简介：前 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/09/17/Papers-MCCS/" title="Papers:MCCS">Papers:MCCS</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-09-17T14:00:17.000Z" title="发表于 2024-09-17 22:00:17">2024-09-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/papers/">papers</a></span></div><div class="content">MCCS: A Service-based Approach to Collective Communication for Multi-Tenant Cloud
研究背景
集体通信在支持许多分布式计算工作负载中起着至关重要的作用。目前有多种广泛使用的集体通信库，如NVIDIA的NCCL、Intel MPI库、OpenMPI和Gloo等。这些库提供了常用的集体通信原语（如AllReduce和AllGather），开发者可以通过将这些库直接链接到其应用程序中来使用。在这些库的高级API之下，集体通信原语通过各种算法（例如基于环或树的AllReduce）实现，并且通常针对硬件进行了高度优化（如NVIDIA的SHARP）。
聚焦问题
在多租户的云环境中，现有集体通信方法的局限性：

缺乏物理网络拓扑信息：在公有云环境中，云租户（使用云服务的用户）通常无法获取底层物理网络的拓扑结构和链路利用率信息。而这些信息对选择高效的通信算法非常重要，比如在分布式训练中经常使用的环形算法（ring-based algorithms）和树形算法（tree-based  algorithms）。由于租户没有这类 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%8D%8F%E8%AE%AE%E5%B1%82%E6%AC%A1%E5%92%8C%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B/" title="计算机网络:协议层次和服务模型">计算机网络:协议层次和服务模型</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-09-16T09:16:13.000Z" title="发表于 2024-09-16 17:16:13">2024-09-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="content">协议层次和服务模型
层次化方式实现复杂网络功能

将网络复杂的功能分成，功能明确的层次，每一层实现了其中一个或一组功能，功能中有其上层可以使用的功能：服务（功能的子集）
本层协议实体相互交互，执行本层的协议动作，目的是实现本层功能，通过接口为上层提供更好的服务
在实现本层协议的时候，直接利用了下层所提供的服务
本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用的）+ 更下层所提供的服务

服务和服务访问点


服务Service：低层实体向上层实体提供它们之间的通信的能力

服务用户(service user)
服务提供者(service provider)
服务访问点（service access point），如传输层的socket套接字，区分不同的上层用户；端口(port)



原语primitive：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语进行交互的

如传输层向应用层提供的原语：关闭socket



服务的类型


面向连接
定义：在传输数据之前，发送方和接收方需要先建立一条连接，数据传输完成后再 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%88%86%E7%BB%84%E5%BB%B6%E6%97%B6%E3%80%81%E4%B8%A2%E5%A4%B1%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F/" title="计算机网络:分组延时、丢失和吞吐量">计算机网络:分组延时、丢失和吞吐量</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-09-16T09:15:57.000Z" title="发表于 2024-09-16 17:15:57">2024-09-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="content">分组延时、丢失和吞吐量
分组丢失和延时是怎样发生的？
在路由器缓冲区的分组队列


分组到达链路的速率超过了链路输出的能力


分组等待排到队头，被传输


链路的队列缓冲区容量有限-&gt;丢失（分组到达一个满的队列时）

丢失的分组可能会被前一个节点或源端系统重传，或根本不重传。



四种分组延时


节点处理延时

检查bit级差错
检查分组首部，决定将分组导向何处



排队延时

在输出链路上等待传输的时间
依赖于路由器的拥塞程度



传输延时

R=链路带宽(bps)
L=分组长度(bits)
将分组发送到链路上的时间=L/R
存储转发延时



传播延时（空间上）


d:物理链路的长度


s:在媒体上的传播速度(约2x10^8 m/sec)

与R（链路带宽）做区分



传播延时=d/s（最后一个bit从出发到终点所经历的时间）


两个节点如果比较近，这个时间可以忽略





节点延时

dprocd_{proc}dproc​：处理延时，通常是微秒数量级或更少
dqueued_{queue}dqueue​：排队延时，取决于拥塞程度
dtransd_{tran ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-Internet%E7%BB%93%E6%9E%84%E5%92%8CISP/" title="计算机网络:Internet结构和ISP">计算机网络:Internet结构和ISP</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-09-16T09:15:38.000Z" title="发表于 2024-09-16 17:15:38">2024-09-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="content">Internet结构和ISP
互联网络结构：网络的网络

端系统通过接入ISPs(Internet Service Providers)连到互联网

住宅，公司和大学的ISPs


接入ISPs相应的必须是互联的

因此任何2个端系统可相互发送分组到对方


导致的“网络的网络”非常复杂

发展和演化是通过经济的和国家的政策驱动的


让我们采用渐进方法描述当前互联网的结构



将每两个ISPs直接相连的问题？不可扩展，代价很大，全连接nnn个ISP需要n2n^2n2量级的链路。
将每个接入ISP都进接到全局ISP（全局范围内覆盖）？客户ISPs和提供者ISPs有经济合约。
但是，如果全局ISPs是可行的业务，有利可图，一定存在竞争关系。也即出现多个global ISP。
合作：通过ISPs之间的合作可以完成业务的扩展，肯定会有互联，对等互联的结算关系（可以通过IXP：Internet Exchange Point进行互联）。
然后业务会细分（全球接入和区域接入），区域网络将出现，用于将接入ISPs连接到全局ISPs。

区分ISP与ICP，后者为内容提供商，如谷歌、百度。当然，后者 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/09/16/POSTS/" title="POSTS">POSTS</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-09-16T06:51:05.000Z" title="发表于 2024-09-16 14:51:05">2024-09-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Post/">Post</a></span></div><div class="content">POSTS
计算LLM需要多少GPU内存的公式和工具
对偶问题
对偶方式

拉格朗日对偶
共轭对偶（非线性优化中用得比较多）

拉格朗日对偶
对原问题的每个约束引入对偶变量（这类变量往往没有什么明显的含义），然后进行线性组合。
线性规划的对偶模型


原始模型-&gt;对偶模型

原始约束-&gt;对偶变量
原始变量-&gt;对偶约束

因此，一个模型是因为约束很多而很难处理时，就可以转变对偶，变成一个约束少变量多的对偶模型。
对于约束很多的模型可以用行生成的方式来处理；对变量很多的模型可以采用列生成的思路来处理。


例

线性规划中一个经典问题的描述如下：

某工厂有两种原料A、B，而且能用其生产两种产品： 1、生产第一种产品需要2个A和4个B，能够获利6；
2、生产第二种产品需要3个A和2个B，能够获利4； 此时共有100个A和120个B，问该工厂最多获利多少？ 设变量为(x1,x2)(x_1,x_2)(x1​,x2​)，表示生产两种产品的数量。将上面的问题用数学表达式描述如下：

max  6x1+4x2s.t.2x1+3x2≤1004x1+2x2≤120\text{max}  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/09/14/Papers-TE-CCL/" title="Papers:TE-CCL">Papers:TE-CCL</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-09-14T14:23:40.000Z" title="发表于 2024-09-14 22:23:40">2024-09-14</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/papers/">papers</a></span></div><div class="content">CacheGen: KV Cache Compression and Streaming for Fast Large Language Model Serving
研究背景


分布式机器学习训练中的数据传输：集体通信


集体通信原理


输入

拓扑结构（topology）：表示网络中节点（如服务器、GPU）和连接方式（如网络链路）的布局。
需求（demand）：the amount of data each GPU wants to send to other GPUs in the topology



输出

路径（routes）：在网络中为每个通信任务选择合适的传输路径，确保数据能够高效地从一个节点传递到另一个节点。
调度（schedule）：为各个任务分配时间和资源，使得任务可以在不同的时间点按计划执行，避免资源冲突。
通过上面两个输出，来最大化带宽利用率/最小化任务完成时间，或者两者都有优化。





问题：现有集体通信方案的局限性

在应对大规模集群时可能会为了扩展性而牺牲质量。



相关工作


精确建模
如MSCCL：精确地建模系统及其计算方面，努力获得接 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/09/13/Papers-CacheGen/" title="Papers:CacheGen">Papers:CacheGen</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-09-13T14:13:28.000Z" title="发表于 2024-09-13 22:13:28">2024-09-13</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/papers/">papers</a></span></div><div class="content">CacheGen: KV Cache Compression and Streaming for Fast Large Language Model Serving
研究背景


LLM的广泛应用


LLM使用特点

prepend an LLM input with a long context containing thousands of tokens or more.


e.g.在输入中加入领域内知识，便于LLM利用以生成回应（无需LLM自身携带领域知识）。
e.g.用户要求 LLM 利用交互期间积累的对话历史记录来补充输入。



问题：答案生成的延时。

Using long contexts poses a challenge to the response generation latency, as no response can be generated until the whole context is loaded and processed by the LLM.



相关工作


增加处理上下文的吞吐量，即提高了处理长上下文的速度或效率，能够在单位时 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/09/12/CRUX/" title="Papers:Crux">Papers:Crux</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-09-12T13:35:23.000Z" title="发表于 2024-09-12 21:35:23">2024-09-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/papers/">papers</a></span></div><div class="content">Crux:GPU-Efficient Communication Scheduling for Deep Learning Training
研究背景
深度学习训练任务计算资源需求高，通常在由云服务商提供的大规模集群上运行，集群中可能有成千上万的 GPU。通常，大量任务在集群中同时执行并共享 GPU 资源，GPU 调度器则负责为这些任务分配 GPU。
然而，多个深度学习任务在同一 GPU 集群上共同执行时，会导致个别任务的训练时间增加和 GPU 利用率下降。由于 GPU 集群的利用率直接影响训练吞吐量和云服务提供商的利润，为了提高利润，需要最大化 GPU 集群的利用率。
研究内容
对深度学习训练（DLT）全生命周期进行分析，发现多个 DLT 任务之间的性能干扰主要源于通信争用。通信包括在同一主机或不同主机上的 GPU 之间同步模型参数、梯度和优化器。当多个 DLT 任务同时执行时，通信争用导致迭代时间显著增加。因此，解决通信争用问题对于提升 GPU 利用率至关重要。
研究亮点
仅进行作业调度只能减轻通信争用的严重程度，但不能消除这一现象。而现有的通信调度策略要么只解决了单一作业场景下的 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/09/09/POST-Fine-tuning-%E8%AE%AD%E7%BB%83%E5%92%8C%E6%8E%A8%E7%90%86%EF%BC%88Training-vs-Inference%EF%BC%89/" title="POST:Fine-tuning - 训练和推理（Training vs Inference）">POST:Fine-tuning - 训练和推理（Training vs Inference）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-09-09T13:13:26.000Z" title="发表于 2024-09-09 21:13:26">2024-09-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Post/">Post</a></span></div><div class="content">POST
[Fine-tuning - 训练和推理（Training vs Inference）](一文彻底搞懂Fine-tuning - 训练和推理（Training vs Inference） (qq.com))
机器学习全过程

收集数据
数据准备
选择模型
训练
评估
参数调整
预估

模型训练过程通常包括以下几个步骤：

数据准备：收集并准备训练数据，包括数据清洗、标注、归一化、分割成训练集和验证集（有时还有测试集）等。
模型选择：根据任务需求和数据特性选择合适的模型架构。这可能是一个简单的线性回归模型，也可能是一个复杂的深度神经网络。
参数初始化：为模型的参数（如权重和偏置）赋予初始值。这些初始值通常是随机生成的，但也可以是预先设计的。
前向传播：将训练数据输入到模型中，通过模型的各层进行计算，得到模型的预测输出。
损失计算：计算模型的预测输出与真实输出之间的差异，即损失值。
反向传播：根据损失值，使用梯度下降等优化算法计算模型中每个参数的梯度，并将这些梯度反向传播回模型的每一层。
参数更新：使用梯度来更新模型的参数，以减少损失值。
迭代训练：重复执行前向传播、损失计算、反 ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/#content-inner">4</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Whatasmallship/imgbed-for-self-blog/wallpaper/4a19190013a4b3f98d0370f6645db29.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Me</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget self_memo" id="self_memo"><div class="item-headline"><i class="https://cdn.jsdelivr.net/gh/Whatasmallship/imgbed-for-self-blog/wallpaper/microsoft_todo_2019_240px.png"></i><span>TodoList</span></div><div class="item-content"><head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>none</title> <style> body, html { margin: 0; padding: 0; width: 100%; height: 100%; } textarea { width: 100%; height: 100%; box-sizing: border-box; /* 包括内边距和边框在内的宽度和高度计算 */ } </style> </head> <body> <textarea placeholder="今天干什么？"></textarea> </body></div></div><div class="sticky_layout"><div class="card-widget user_map" id="user_map"><div class="item-headline"><i></i><span>Visitors</span></div><div class="item-content"><script type="text/javascript" id="clstr_globe" src="//clustrmaps.com/globe.js?d=5V2tOKp8qAdRM-i8eu7ETTO9ugt5uKbbG-U7Yj8uMl8"></script></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Me</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">理论是灰色的，而生活之树长青。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>